var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import isEqual from 'lodash/isEqual';
import { FETCH_END } from '../../../actions';
import { CREATE, DELETE, DELETE_MANY, GET_LIST, GET_MANY, GET_MANY_REFERENCE, GET_ONE, UPDATE, UPDATE_MANY, } from '../../../core';
import getFetchedAt from '../../../util/getFetchedAt';
/**
 * Make the fetchedAt property non enumerable
 */
export var hideFetchedAt = function (records) {
    Object.defineProperty(records, 'fetchedAt', {
        enumerable: false,
        configurable: false,
        writable: false,
    });
    return records;
};
/**
 * Add new records to the pool, and remove outdated ones.
 *
 * This is the equivalent of a stale-while-revalidate caching strategy:
 * The cached data is displayed before fetching, and stale data is removed
 * only once fresh data is fetched.
 */
export var addRecordsAndRemoveOutdated = function (newRecords, oldRecords) {
    if (newRecords === void 0) { newRecords = []; }
    var newRecordsById = {};
    newRecords.forEach(function (record) { return (newRecordsById[record.id] = record); });
    var newFetchedAt = getFetchedAt(newRecords.map(function (_a) {
        var id = _a.id;
        return id;
    }), oldRecords.fetchedAt);
    var records = { fetchedAt: newFetchedAt };
    Object.keys(newFetchedAt).forEach(function (id) {
        return (records[id] = newRecordsById[id]
            ? isEqual(newRecordsById[id], oldRecords[id])
                ? oldRecords[id] // do not change the record to avoid a redraw
                : newRecordsById[id]
            : oldRecords[id]);
    });
    return hideFetchedAt(records);
};
/**
 * Add new records to the pool, without touching the other ones.
 */
export var addRecords = function (newRecords, oldRecords) {
    if (newRecords === void 0) { newRecords = []; }
    var newRecordsById = __assign({}, oldRecords);
    newRecords.forEach(function (record) {
        newRecordsById[record.id] = isEqual(record, oldRecords[record.id])
            ? oldRecords[record.id]
            : record;
    });
    var updatedFetchedAt = getFetchedAt(newRecords.map(function (_a) {
        var id = _a.id;
        return id;
    }), oldRecords.fetchedAt);
    Object.defineProperty(newRecordsById, 'fetchedAt', {
        value: __assign(__assign({}, oldRecords.fetchedAt), updatedFetchedAt),
        enumerable: false,
    });
    return newRecordsById;
};
export var addOneRecord = function (newRecord, oldRecords, date) {
    var _a, _b;
    if (date === void 0) { date = new Date(); }
    var newRecordsById = __assign(__assign({}, oldRecords), (_a = {}, _a[newRecord.id] = isEqual(newRecord, oldRecords[newRecord.id])
        ? oldRecords[newRecord.id] // do not change the record to avoid a redraw
        : newRecord, _a));
    return Object.defineProperty(newRecordsById, 'fetchedAt', {
        value: __assign(__assign({}, oldRecords.fetchedAt), (_b = {}, _b[newRecord.id] = date, _b)),
        enumerable: false,
    });
};
var includesNotStrict = function (items, element) {
    return items.some(function (item) { return item == element; });
}; // eslint-disable-line eqeqeq
/**
 * Remove records from the pool
 */
export var removeRecords = function (removedRecordIds, oldRecords) {
    if (removedRecordIds === void 0) { removedRecordIds = []; }
    var records = Object.entries(oldRecords)
        .filter(function (_a) {
        var key = _a[0];
        return !includesNotStrict(removedRecordIds, key);
    })
        .reduce(function (obj, _a) {
        var _b;
        var key = _a[0], val = _a[1];
        return (__assign(__assign({}, obj), (_b = {}, _b[key] = val, _b)));
    }, {
        fetchedAt: {}, // TypeScript warns later if this is not defined
    });
    records.fetchedAt = Object.entries(oldRecords.fetchedAt)
        .filter(function (_a) {
        var key = _a[0];
        return !includesNotStrict(removedRecordIds, key);
    })
        .reduce(function (obj, _a) {
        var _b;
        var key = _a[0], val = _a[1];
        return (__assign(__assign({}, obj), (_b = {}, _b[key] = val, _b)));
    }, {});
    return hideFetchedAt(records);
};
var initialState = hideFetchedAt({ fetchedAt: {} });
var dataReducer = function (previousState, _a) {
    if (previousState === void 0) { previousState = initialState; }
    var payload = _a.payload, meta = _a.meta;
    if (meta && meta.optimistic) {
        if (meta.fetch === UPDATE) {
            var updatedRecord = __assign(__assign({}, previousState[payload.id]), payload.data);
            return addOneRecord(updatedRecord, previousState);
        }
        if (meta.fetch === UPDATE_MANY) {
            var updatedRecords = payload.ids.map(function (id) { return (__assign(__assign({}, previousState[id]), payload.data)); });
            return addRecordsAndRemoveOutdated(updatedRecords, previousState);
        }
        if (meta.fetch === DELETE) {
            return removeRecords([payload.id], previousState);
        }
        if (meta.fetch === DELETE_MANY) {
            return removeRecords(payload.ids, previousState);
        }
    }
    if (!meta || !meta.fetchResponse || meta.fetchStatus !== FETCH_END) {
        return previousState;
    }
    switch (meta.fetchResponse) {
        case GET_LIST:
            return addRecordsAndRemoveOutdated(payload.data, previousState);
        case GET_MANY:
        case GET_MANY_REFERENCE:
            return addRecords(payload.data, previousState);
        case UPDATE:
        case CREATE:
        case GET_ONE:
            return addOneRecord(payload.data, previousState);
        default:
            return previousState;
    }
};
export var getRecord = function (state, id) { return state[id]; };
export default dataReducer;
